<!DOCTYPE html>
<html lang="en">
<head>
    <title>AmaraJS</title>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="style.css">
    <link rel="stylesheet" type="text/css" href="github.css">
    <script src="highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
    <a class="hide" href="#main">Skip to main content.</a>
    <header>
        <h1>AmaraJS</h1>
        <h2>feature-based application development</h2>
        <nav>
            <li><a href="https://github.com/amarajs">GitHub</a></li>
            <li><a href="/guide">Walkthrough</a></li>
        </nav>
    </header>
    <main id="main">

<h3 id="whyamarajs">Why AmaraJS?</h3>
<nav>
    <li><a href="#whyamarajs">Why AmaraJS</a></li>
    <li><a href="#api">API</a></li>
    <li><a href="#pluginmiddleware">Plugin Middleware</a></li>
    <li><a href="#developingfeatures">Developing Features</a></li>
    <li><a href="#writingmiddleware">Writing Middleware</a></li>
    <li><a href="#developingabstractionsforamarajs">Developing Abstractions</a></li>
    <li><a href="#bestpractices">Best Practices</a></li>
    <li><a href="#amarainaction">Sample Use Case</a></li>
    <li><a href="#faq"><acronym title="Frequently Asked Questions">FAQ</acronym></a></li>
</nav>

<p>Developers write features. These features are often bundled together into some kind of container, such as a class or a component. There are best practices for object-oriented and functional programming, such as composition, to keep code as decoupled and maintainable as possible. But even following best practices can result in ever-increasing technical debt due to real-world changing requirements.</p>

<p>For example, let's say you implemented a button component. You try to make it as "dumb" as possible, even using pure functions, so that its behavior depends entirely on properties passed to it by a "smarter" consumer. You've just completed coding and delivered your component to other developers. That's when the feature requests start coming in:</p>

<ul>
<li>Can we add theme support?</li>

<li>Can we use different themes based on where the button is in the DOM?</li>

<li>Can we send click events to Google Analytics automatically?</li>

<li>Can we send different values to GA based on where the button is in the DOM?</li>

<li>Can we show a loading treatment tied to an asynchronous action?</li>

<li>Can we add standard keyboard shortcuts to buttons when they're in dialogs?</li>

<li>Can we automatically add ARIA attributes based on all the above features?</li>
</ul>

<p>There are good design approaches to implement all of these features, but they all require either modifying or wrapping the button's existing DOM structure, event handlers, lifecycle methods, and/or CSS styling. Composition is great, but it shouldn't be the only tool in our toolbox.</p>

<h4>Every single line of code is technical debt.</h4>

<p>All code is technical debt, but that's not the code's fault - it's our fault for how we group our code together. Even the best-designed code often ends up tightly coupled over time as new features are weaved into existing functionality.</p>

<p>With that in mind, our goals as developers should be:</p>

<ol>
<li>Write the minimum amount of code required to deliver a feature.</li>

<li>Implement one (and only one) feature in each unit of code we deliver.</li>

<li>Only change existing code when fixing bugs.</li>
</ol>

<p>Ideally, we could just write <em>features</em>, not classes or components.</p>

<h4><strong>AmaraJS</strong> is about writing features.</h4>

<p>Developers in AmaraJS write a feature by specifying a target (a DOM node in the case of a web application), the feature output (e.g. a set of CSS classes to apply), and any optional conditions that might affect the feature output (such as whether an asynchronous operation is still in progress).</p>

<p>Whenever an element in the DOM matches the feature's target &mdash; or whenever the inputs to the feature change &mdash; the associated code will be re-evaluated. If the results have changed, they will be applied to the target using the appropriate plugin middleware.</p>

<p><em>(If that doesn't make sense now, don't worry &mdash; you'll be an Amara expert soon enough!)</em></p>

<p>In other words, features written in AmaraJS assemble themselves automatically. There's no need for a component or a class to group features together. That side-steps many of the potential bugs that come from trying to integrate new features into existing code.</p>

<h4>AmaraJS is platform agnostic.</h4>

<p>Although primarily intended for web-based application development, <code>@amarajs/core</code> is platform agnostic and can run anywhere JavaScript can run, including NodeJS environments.</p>

<p>The responsibility for connecting core Amara functionality to a specific environment is done using  "engine" middleware. All features developed in Amara will have one or more "targets" they apply to, and it's the engine's job to manage targets appropriately for its given platform.</p>

<h4>AmaraJS uses existing standards.</h4>

<p>Features in AmaraJS that target web browsers use normal HTML DOM, CSS, and Events under the hood. There's no framework magic you need to understand, no dependency injection, no arcane lifecycles with "gotchas" you have to remember, etc.</p>

<p>That also means AmaraJS can be dropped into any existing website without impacting current frameworks. If you wanted to add keyboard navigation to an existing Angular, Vue, or React component, you could do so without modifying that component's code. Just write your feature to target the component's DOM and AmaraJS will apply the new functionality for you.</p>

<h3 id="api">API</h3>

<p>Each <code>Amara</code> instance has 3 methods:</p>

<table id="api-table">
    <tbody>
        <tr><td><code>add</code></td><td><code>Object</code></td><td>Registers the specified feature with <code>@amarajs/core</code>. The argument should be a valid AmaraJS feature object. The required and optional properties are outlined later in this document. You can call <code>add</code> at any time, before or after bootstrap or configuration.</td></tr>
        <tr><td><code>config</code></td><td><code>String</code>, <code>Function</code></td><td>Registers a configuration method to further control how AmaraJS works with features. The currently configurable options are <code>"filter"</code> and <code>"sorter"</code>. Examples are below.</td></tr>
        <tr><td><code>bootstrap</code></td><td><code>any</code></td><td>Initializes AmaraJS with the given target. The target type to provide depends on which <code>engine</code> middleware you provided to the <code>Amara</code> constructor. For example, <a href="https://github.com/amarajs/plugin-engine-browser"><code>@amarajs/plugin-engine-browser</code></a> expects a DOM node.</p></td></tr>
    </tbody>
    <thead>
        <tr><th>method</th><th>arguments</th><th>description</th></tr>
    </thead>
</table>

<p>Each method returns the <code>Amara</code> instance to enable chaining:</p>

<pre><code contenteditable spellcheck="false" class="javascript language-javascript">const amara = new Amara([/* middleware */])
    .config('sorter', /* sort function */)
    .config('filter', /* filter function */)
    .add(/* feature 1 */)
    .add(/* feature 2 */)
    .bootstrap(/* target */);
</code></pre>

<h4 id="configurationfunctions">Configuration Functions</h4>

<p>You can further customize your <code>Amara</code> instance by providing any number of optional configuration functions, including <strong>filter</strong> and <strong>sorter</strong> methods.</p>

<p>Each feature added to your <code>Amara</code> instance has 3 required properties (and 1 optional property), but you can also add any number of custom properties to the features you write. Combining custom properties with configuration functions enables you to control how your features are applied at run-time.</p>

<pre><code contenteditable spellcheck="false" class="javascript language-javascript">// sorting features by a custom `priority` property:
amara.config('sorter', (lhs, rhs) =&gt; rhs.priority - lhs.priority)
</code></pre>

<pre><code contenteditable spellcheck="false" class="javascript language-javascript">// filtering out "disabled" features:
amara.config('filter', (feature) =&gt;
    !('enabled' in feature) || feature.enabled)
</code></pre>

<p>If you specify multiple config functions of each type, they will be invoked in the order they were registered:</p>

<pre><code contenteditable spellcheck="false" class="javascript language-javascript">amara
    // this runs first:
    .config('sorter', (lhs, rhs) =&gt; rhs.priority - lhs.priority)
    // and then this runs:
    .config('sorter', (lhs, rhs) =&gt; Math.random()) // don't do this
</code></pre>

<h3 id="pluginmiddleware">Plugin Middleware</h3>

<p>There is a growing list of Amara middleware available for use. Standard middleware includes:</p>

<ul>
<li><a href="https://github.com/amarajs/plugin-engine-browser"><code>@amarajs/plugin-engine-browser</code></a> <br />
Provides <code>@amarajs/core</code> with functionality related to DOM nodes, for use in web-based applications.</li>

<li><a href="https://github.com/amarajs/plugin-css"><code>@amarajs/plugin-css</code></a> <br />
Attach CSS styles and class names to DOM nodes.</li>

<li><a href="https://github.com/amarajs/plugin-dom"><code>@amarajs/plugin-dom</code></a> <br />
Add HTML to DOM nodes.</li>

<li><a href="https://github.com/amarajs/plugin-events"><code>@amarajs/plugin-events</code></a> <br />
Attach event handlers to DOM nodes.</li>

<li><a href="https://github.com/amarajs/plugin-redux"><code>@amarajs/plugin-redux</code></a> <br />
Dispatch actions against a Redux store.</li>

<li><a href="https://github.com/amarajs/plugin-router"><code>@amarajs/plugin-router</code></a> <br />
Dynamic client-side routing, including nested and sibling routes.</li>
</ul>

<h3 id="developingfeatures">Developing Features</h3>

<p>Once you've registered the middleware you want with your Amara instance, you can begin developing features. Features are just object literals. Out of the box, every feature has 3 required properties and 1 optional property:</p>

<table id="feature-table">
    <tbody>
        <tr><td>type</td><td><code>String</code></td><td><code>true</code></td><td>Each middleware specifies the <code>type</code> value it handles.</td><td><code>"css"</code><br><code>"dom"</code><br><code>"events"</code></td></tr>
        <tr><td>targets</td><td><code>String[]</code></td><td><code>true</code></td><td>An array of target selector strings. The <code>engine</code> plugin you choose determines how these selectors are handled. For example, the <a href="https://github.com/amarajs/plugin-engine-browser"><code>@amarajs/plugin-engine-browser</code></a> plugin expects CSS selectors.</td><td><code>["#main"]</code><br><code>['input[type="button"]']</code><br><code>['a[href^="#"]']</code></td></tr>
        <tr><td>apply</td><td><code>Function</code></td><td><code>true</code></td><td>A function that returns whatever values the middleware type expects. For example, <a href="https://github.com/amarajs/plugin-events"><code>@amarajs/plugin-events</code></a> expects a map of event names to handlers.</td><td>(see plugin documentation)</td></tr>
        <tr><td>args</td><td><code>Object</code></td><td><code>false</code></td><td>A map of argument names to selector functions. The value returned by the selector function will be passed to your <code>apply</code> function in an object literal, along with any other arguments you specify.</td><td>(see example below)</p></td></tr>
    </tbody>
    <thead><tr><th>property</th><th>type</th><th>required</th><th>description</th><th>example</th></tr></thead>
</table>

<p>Each feature is also given an <code>id</code> number when added that is used internally to ensure features are applied in the order they were added. If you specify your own <code>id</code> property, it will be overwritten by Amara.</p>

<h4 id="example1">Example #1</h4>

<pre><code contenteditable spellcheck="false" class="javascript language-javascript">// conditionally add a loading class to any DOM
// nodes with a `progress` attribute, but only
// when the application state says we are loading
amara.add({
    type: 'class', // from @amarajs/plugin-css
    targets: ['[progress]'],
    args: {
        // NOTE: the `state` param is provided
        // by the `@amarajs/plugin-redux` middleware
        isLoading: ({state}) =&gt; state.loading
    },
    apply: function getClassNames({ isLoading }) {
        // the @amarajs/plugin-css middleware tells
        // us what to return, either an array of
        // active class names or an object whose
        // keys are class names and whose boolean
        // values determine if the class is active
        return isLoading ? ['loading'] : [];
        // or:
        return {loading: isLoading};
    }
});
</code></pre>

<h4 id="example2">Example #2</h4>

<pre><code contenteditable spellcheck="false" class="javascript language-javascript">// open a help panel anytime a link with a help
// topic is clicked; use event delegation because
// we care about app performance
amara.add({
    type: 'events', // from @amarajs/plugin-events
    targets: ['main'], // use event delegation
    apply: () =&gt; ({
        // we can use selectors to ensure our handler
        // only fires for clicks on a DOM node matching
        // the given CSS selector (in this case, any
        // anchor elements with a "help-topic" attribute)
        'click a[help-topic]': function helpWanted(e) {
            const topic = e.target.getAttribute('help-topic');
            // use an action creator to dispatch a
            // router:navigate event targeting the #help
            // container, with whatever help-topic was
            // specified on the link as the route path
            e.dispatch(navigate('#help', `topics/${topic}`));
            // the URL hash will now look like:
            // #!#help://topics/&lt;whatever topic&gt;
            // see the `@amarajs/plugin-router` documentation
            // for details
            e.preventDefault(); // cancel normal anchor behavior
            e.stopPropagation(); // stop bubbling this event
        }
    })
});
</code></pre>

<p>In the example above, the associated help feature might look like this:</p>

<pre><code contenteditable spellcheck="false" class="javascript language-javascript">// register the #help element as a recipient of
// routes matching the "topics/:topic" pattern
amara.add({
    type: 'route', // from @amarajs/plugin-router
    targets: ['#help'],
    // when route tokens are used, the router plugin
    // will provide a `routeParams` object to your
    // args map selector functions, so you can inspect
    // the value and provide it to your apply functions
    apply: () =&gt; ['topics/:topic']
});

// we can hard-code HTML content for when the route
// is "topics/amarajs". this approach might be useful
// in a siloed environment where teams are responsible
// for providing help content for their specific areas
amara.add({
    type: 'dom', // from @amarajs/plugin-dom
    targets: ['#help[route="topics/amarajs"]'],
    apply: () =&gt; h('div', `Information about AmaraJS`)
});

// or, we could use the `routeParams` object to make
// our help content a bit more dynamic. to do so, we'll
// provide our content when the help container's route
// attribute starts with "topics/"; we're going to grab
// the desired topic from the routeParams object, and
// then provide that topic to our apply function, so it
// can pull the associated help message from our static
// content map (or else show a default message if no help
// content was found)
import content from 'assets/content/help';
amara.add({
    type: 'dom',
    targets: ['#help[route^="topics/"]'],
    args: {topic: ({routeParams}) =&gt; routeParams.topic},
    apply: ({topic}) =&gt; content[topic] || 'No help found!'
});
</code></pre>

<p>Hopefully, you're starting to see the power of the AmaraJS approach. Adding a contextual help system didn't require modifying any existing code. We simply grafted our feature onto the existing site.</p>

<p>We could even have gone further by dynamically adding <code>[help-topic]</code> attributes onto specific DOM elements when we had help topics available for those areas -- again, without modifying existing code or changing our current components' HTML.</p>

<p>The same process applies to all development in AmaraJS: implement your new feature using a combination of plugins &mdash; specifying your target selectors and any dynamic inputs &mdash; and everything will be applied for you automatically.</p>

<p>Later on &mdash; once we learn more about how everything works together &mdash; we'll show another example of how to use AmaraJS to code some neat functionality. But first, let's talk about <em>middleware</em>.</p>

<h3 id="writingmiddleware">Writing Middleware</h3>

<p>Put simply, plugin middleware provides cross-cutting functionality to the features that you write.</p>

<p>If the standard plugin middleware doesn't meet your needs (and if you can't find appropriate middleware already developed by the community) then it's easy to write your own. In fact, we're going to write our own Google Analytics middleware a bit later on.</p>

<p>But first, here's the standard plugin middleware template:</p>

<pre><code contenteditable spellcheck="false" class="javascript language-javascript">export default function MyMiddleware(options) {

    // if you want to let the consumer configure your
    // middleware (e.g. by providing an API key), they
    // should do so using an `options` object. make
    // sure your documentation specifies the available
    // configuration values and their defaults

    return function createHandler(dispatch) {

        // if you want to dispatch actions to other
        // plugin middleware, use the `dispatch`
        // function passed here by `@amarajs/core`

        return function handler(action) {

            // actions dispatched by the user, by
            // AmaraJS, or by other plugins will be
            // sent here for optional handling

            // the one action you will probably want
            // to handle is "core:apply-target-results",
            // which is what links your plugin "type"
            // with a target (provided by the engine)
            // and the return values of any `apply`
            // methods that matched the target. the
            // action payload is an object literal
            // whose keys are plugin types (e.g. "css"
            // or "events") and whose values are of type
            // Map&lt;Target, ApplyResults[]&gt;

            switch(action.type) {
            case 'core:apply-target-results':
                if (MY_PLUGIN_TYPE in action.payload) {
                    action.payload[MY_PLUGIN_TYPE].forEach(
                        function applyResults(results, target) {
                            // ... your code here ...
                        });
                }
                break;
            }

        };

    };

}
</code></pre>

<h4 id="middlewareactions">Middleware Actions</h4>

<p>Amara dispatches various actions that plugin middleware can listen and respond to.</p>

<table id="middleware-table">
    <tbody>
        <tr><td><code>"core:bootstrap"</code></td><td><code>{</code><br>&nbsp;&nbsp;<code>target,</code><br>&nbsp;&nbsp;<nobr><code>register: (string, fn) =&gt; fn</code></nobr><br><code>}</code></td><td>Notifies middleware of the bootstrapped target, and provides a method middleware can use to register one (and only one) "argument provider" function for a given key.<p>The provider should accept a single argument, <code>target</code>, and should return the value that will be provided to a feature's <code>args</code> selector method for the specified key. See <code>@amarajs/plugin-router</code>'s <a href="https://github.com/amarajs/plugin-router">source code</a> for an example.<p>When invoked, the register method returns a function that middleware can invoke to un-register the provider method.</td></tr>
        <tr><td><code>"core:features-added"</code></td><td><code>Set&lt;feature&gt;</code></td><td>Notifies middleware that the user has added one or more features to the amara instance.</td></tr>
        <tr><td><code>"core:change-occurred"</code></td><td><code>string</code></td><td>Usually dispatched by middleware to notify the AmaraJS instance that it should re-evaluate any features which accessed the specified <code>args</code> key. This is usually fired by the same middleware which registered an "argument provider" method during <code>core:bootstrap</code>.</td></tr>
        <tr><td><nobr><code>"core:populate-feature-targets"</code></nobr></td><td><code>Map&lt;feature, Set&lt;any&gt;&gt;</code></td><td>The AmaraJS instance has identified some features which need to be re-applied, and would like the "engine" plugin to add the appropriate targets to the given Set.</td></tr>
        <tr><td><code>"core:enqueue-apply"</code></td><td><code>Array&lt;{feature, target}&gt;</code></td><td>Usually fired by "engine" middleware to notify the AmaraJS instance exactly which features and targets need to be re-applied at the end of the current frame.</td></tr>
        <tr><td><code>"core:apply-target-results"</code></td><td><code>Map&lt;target, any[]&gt;</code></td><td>Sent to middleware so they can apply the given array of feature <code>apply</code> methods results to the specified target. For example, <a href="https://github.com/amarajs/plugin-dom"><code>@amarajs/plugin-dom</code></a> receives an array of VirtualDOM nodes and will apply them to the target HTML node in order.</td></tr>
        <tr><td><code>"error"</code></td><td><code>Error</code></td><td>An error occurred in a middleware handler while dispatching an action. Because middleware may operate as a pipeline, subsequent middleware handlers will <em>not</em> be invoked for the given action.</p></td></tr>
    </tbody>
<thead>
    <tr><th>action.type</th><th>action.payload</th><th>purpose</th></tr>
</thead>
</table>

<h3 id="developingabstractionsforamarajs">Developing Abstractions for AmaraJS</h3>

<p>No one likes boilerplate &mdash; writing the same code over and over is tedious. And while each feature object only has 3 required properties, you may find yourself wanting some way to reduce your typing. (Or maybe you just don't want to remember if the <code>targets</code> property expects a string or a string array.)</p>

<p>We prefer to leave this kind of abstraction up to the consumers and community. That said, here are 2 approaches we've seen used or considered on various AmaraJS projects.</p>

<h4 id="factorymethod">Factory Method</h4>

<pre><code contenteditable spellcheck="false" class="javascript language-javascript">// utils.js

const factory = (type) =&gt; (targets, args, apply) =&gt; ({
    type,
    args: apply ? args : {},
    apply: apply ? apply : args,
    targets: Array.isArray(targets) ? targets: [targets]
});

export const dom = factory('dom');
export const css = factory('class');
export const style = factory('style');
export const events = factory('events');
export const routes = factory('route');
</code></pre>

<p>This lets you write code like:</p>

<pre><code contenteditable spellcheck="false" class="javascript language-javascript">import { dom, routes } from 'utils';

amara
    .add(routes('#main', () =&gt; ['topics/:topic']))
    .add(dom(
        '#main [route^="topics/"]',
        {
            topics: ({state}) =&gt; state.topics,
            topic: ({routeParams}) =&gt; routeParams.topic
        },
        ({topics, topic}) =&gt; topics[topic] || `No topic.`
    ));
</code></pre>

<h4 id="decorators">Decorators</h4>

<p>Some developers may still prefer to group their features into classes. Using <a href="https://github.com/amarajs/decorators">@amarajs/decorators</a> makes this easy:</p>

<pre><code contenteditable spellcheck="false" class="javascript language-javascript">import { targets, connect, routes, dom } from '@amarajs/decorators';

@targets('#main')
export default class Router {

    @routes()
    function getRoutes() {
        return ['topics/:topic'];
    }

    @dom('&amp;[route^="topics/"]')
    @connect({
        topics: ({state}) =&gt; state.topics,
        topic: ({routeParams}) =&gt; routeParams.topic
    })
    function getDOM({topics, topic}) {
        return topics[topic];
    }

}
</code></pre>

When a new instance of the Router class is constructed, the following code will be executed under the hood:

<pre><code contenteditable spellcheck="false" class="javascript language-javascript">amara.add({
    type: 'route',
    targets: ['#main'],
    apply: () => ['topics/:topic']
});

amara.add({
    type: 'dom',
    targets: ['#main[route^="topics/"]'],
    args: {
        topics: ({state}) => state.topics,
        topic: ({routeParams}) => routeParams.topic
    },
    apply: ({topics, topic}) => topics[topic]
});
</code></pre>

<h3 id="bestpractices">Best Practices</h3>

<h4 id="1simplifyyourargsselectors">#1: Simplify your <code>args</code> selectors.</h4>

<p>For performance reasons, AmaraJS monitors each feature's <code>args</code> map to determine which middleware-provided parameters are accessed the first time each selector is invoked. This allows Amara to limit feature re-application only to when those specific properties change.</p>

<p>For example, if your feature's <code>args</code> map never accesses <code>routeParams</code>, but <a href="https://github.com/amarajs/plugin-router"><code>@amarajs/plugin-router</code></a> notified Amara that the <code>routeParams</code> had changed, then Amara won't re-invoke your feature's <code>apply</code> method.</p>

<p>Accordingly, your features' <code>args</code> maps should be written to avoid conditional access to map properties. For example, code like this should be avoided because it conditionally accesses the <code>state</code> property provided by <a href="https://github.com/amarajs/plugin-redux"><code>@amarajs/plugin-redux</code></a>:</p>

<pre><code contenteditable spellcheck="false" class="javascript language-javascript">amara.add({
    type: 'whatever',
    targets: ['something'],
    args: {
        myArg: ({state, routeParams}) =&gt; {
            if (routeParams.someKey) {
                return state.propA;
            }
            return null;
        }
    },
    apply: ({myArg}) =&gt; {}
});
</code></pre>

<p>Instead, a better <code>args</code> selector eliminates the conditional access:</p>

<pre><code contenteditable spellcheck="false" class="javascript language-javascript">amara.add({
    type: 'whatever',
    targets: ['something'],
    args: {
        myArg: ({state, routeParams}) =&gt; {
            const key = routeParams.someKey;
            const prop = state.propA;
            return key ? prop : null;
        }
    },
    apply: ({myArg}) =&gt; {}
});
</code></pre>

<p>That said, an even <em>better</em> approach is to isolate each selector, allowing for composition and re-use through a library like <a href="https://github.com/reactjs/reselect">reselect</a>:</p>

<pre><code contenteditable spellcheck="false" class="javascript language-javascript">import { createSelector: select } from 'reselect';

const prop = ({state}) =&gt; state.propA;
const key = ({routeParams}) =&gt; routeParams.someKey;

const myArg = select(key, prop, (k, p) =&gt; {
    return k ? p : null;
});

amara.add({
    type: 'whatever',
    targets: ['something'],
    args: { myArg },
    apply: ({myArg}) =&gt; {}
});
</code></pre>

<h4 id="2exportyourtargetselectorstrings">#2: Export your target selector strings.</h4>

<p>This one takes a cue from Redux, where the best practice is to export action types and selector functions. There are obvious benefits to defining your constants once and simply importing them where needed. The same rationale applies to target selector strings in AmaraJS:</p>

<pre><code contenteditable spellcheck="false" class="javascript language-javascript">// targets.js
export const HelpPanel = ['#help'];
export const ProgressIndicators = ['div[progress]'];

// my-feature.js
import { ProgressIndicators } from 'targets';

amara.add({
    type: 'dom',
    targets: ProgressIndicators,
    apply: () =&gt; `progress html`
});
</code></pre>

<p>Where and how you export target selectors is up to you. Some developers prefer a single "targets.js" file where all selectors are defined. Others may prefer to export selectors closer to where their features are coded.</p>

<h4 id="3structureyourprojectbyfeaturenotbycomponent">#3: Structure your project by feature, not by component.</h4>

<p>Modern web applications tend to use component-driven development. Of course, you can do something similar with AmaraJS; however, developing individual features opens up additional options for structuring large projects.</p>

<p>For example, developers in an Agile environment might be assigned user stories representing the features they need to develop for their next release. In that setup, you may want to write each feature in a separate file, perhaps named using the story id number:</p>

<pre><code contenteditable spellcheck="false">assets/
    svg/
    lang/
features/
    FEAT-120.js
    FEAT-142.js
    FEAT-153.js
    ...
    FEAT-398.js
    FEAT-402.js
</code></pre>

<p>Of course, this approach has tradeoffs. You lose the benefit of meaningful folder and file names. However, you do gain some advantages. The primary benefit of this organization is that loose feature couping is enforced by default (remember developer goal #2?).</p>

<p>It also opens up some interesting <em>tangential</em> possibilities:</p>

<ul>
<li>tighter integration with issue trackers</li>

<li>easily identify which features are in your environments</li>

<li>implement server-side feature switches on a per-story basis</li>
</ul>

<p>We're extremely curious to see what kinds of tooling become possible once feature-based coding is more common.</p>

<h4 id="4smartvsdumbstillapplies">#4: "Smart" vs. "dumb" still applies.</h4>

<p>In component-driven development, "dumb" components depend only on the properties passed to them while "smart" components also depend on application state. Of course, in AmaraJS, we don't write components &mdash; we write features. But the same principles apply.</p>

<p>A "smart" feature is one with an <code>args</code> map, whose selector functions' return values are piped into the <code>apply</code> function as inputs. A "dumb" feature has no <code>args</code> map; accordingly, its <code>apply</code> function takes no inputs.</p>

<p>Not surprisingly, you should follow the industry standard of preferring "dumb" features as much as possible, not just because it encourages re-usability, but also because AmaraJS can optimize features that have no <code>args</code> map by caching and reusing the first results returned from the <code>apply</code> function.</p>

<h4 id="5placecrosscuttingbusinesslogicinmiddleware">#5: Place cross-cutting business logic in middleware.</h4>

<p>In MVC and component-driven development, a controller typically imports shared functionality, either through dependency injection or module imports. In Redux-connected components, they might simply dispatch an action and rely on a reducer or async middleware to handle it.</p>

<p>Each approach bypasses the browser's own built-in event system and so misses out on some neat possibilities.</p>

<p>If you're using <a href="https://github.com/amarajs/plugin-events"><code>@amarajs/plugin-events</code></a>, any DOM event dispatched from your handler will eventually bubble up to the node you used to bootstrap your <code>Amara</code> instance. When this happens, the middleware will automatically route that event through <code>Amara</code> as an action, enabling your other middleware to respond to that action in turn. For example, <a href="https://github.com/amarajs/plugin-redux"><code>@amarajs/plugin-redux</code></a> will further route that action to your Redux store, at which point your reducers, saga middleware, or thunks could execute their business logic.</p>

<p>DOM events should be preferred over dependency injection and direct Redux dispatches whenever possible so that any DOM nodes between the dispatching node and the bootstrap node can interact with the event (or cancel it entirely), <em>before</em> it reaches your other AmaraJS middleware.</p>

<p>Doing so opens up some interesting opportunities. For example, features targeting the intervening DOM nodes could:</p>

<ul>
<li>attach contextual information to a logging event</li>

<li>cancel Redux actions originating from disabled screen areas</li>

<li>open a contextual help panel when an error occurs inside a specific screen area</li>

<li>flush tracking data to a server when an e-commerce purchase occurs</li>
</ul>

<p>Placing your cross-cutting logic in middleware enables DOM event interception, opening up a whole new layer of extension points and context-aware feature enhancements.</p>

<p>But enough talk. Let's code something!</p>

<h3 id="amarainaction">Amara in Action: Sample Use Case</h3>

<p>Remember that hypothetical request for our button component? They wanted to track click events in Google Analytics differently depending on where the button was on the screen. Let's see how we might implement that feature using the best practices we just learned.</p>

<p>First, we're going to place our cross-cutting logic in a new middleware plugin. We could publish this plugin separately, or we could search for one already written by the AmaraJS community, but it's easy enough to write one that meets our basic needs:</p>

<pre><code contenteditable spellcheck="false" class="javascript language-javascript">// middleware/analytics.js

export default function GoogleAnalytics(options) {

    // consider throwing an Error if the account
    // wasn't provided
    const account = options.accountNumber;

    function downloadAnalyticsScript(document) {
        const script = document.createElement('script');
        script.setAttribute('type', 'text/javascript');
        script.innerHTML = `
            // &lt;snip&gt; code to download analytics.js
            ga('create', '${account}', 'auto');
            ga('send', 'pageview');
        `
        document.appendChild(script);
    }

    return function createHandler() {

        return function handler(action) {

            switch(action.type) {
            case 'core:bootstrap':
                // create script tag to download analytics.js
                let bootstrapNode = action.payload.target;
                let document = bootstrapNode.documentElement;
                downloadAnalyticsScript(document);
                break;
            case 'tracking-event':
                ga('send', {
                    hitType: 'event',
                    eventCategory: action.payload.category,
                    eventAction: action.payload.action,
                    // Google suggests using "label" to
                    // categorize events, even though they
                    // already have a "category" property   ¯\(°_o)/¯
                    // as you'll see later, we've been using
                    // an array to store our label values,
                    // so we'll join that array together to
                    // get our final label value
                    eventLabel: action.payload.label.join(' &gt; ')
                });
                break;
            }

        };

    };

}
</code></pre>

<p>Now, let's assume that any DOM element that wants to add contextual tracking data will do so through a new attribute called <code>tracking-context</code>. For example:</p>

<pre><code contenteditable spellcheck="false" class="html language-html">&lt;section id="help" tracking-context="help panel"&gt;
  ...
&lt;/section&gt;
</code></pre>

<p>With this in mind, we'll update our hypothetical "targets.js" file with the new target selector:</p>

<pre><code contenteditable spellcheck="false" class="javascript language-javascript">// targets.js
...
export const TrackingContext = ['[tracking-context]'];
...
</code></pre>

<p>Now we can begin coding our feature, which is really just 2 separate behaviors:</p>

<pre><code contenteditable spellcheck="false" class="javascript language-javascript">// context-tracking.js

import { amara } from './bootstrap';
import { createAction } from './utils';
import { ButtonComponent, TrackingContext } from './targets';

amara

    // first, we want to dispatch a "tracking-event" custom DOM
    // event whenever our button component is clicked. the event
    // details will include a default "action" and "category"
    // and will use the inner text of our button as the "label"
    .add({
        type: 'events',
        targets: ButtonComponent,
        apply: () =&gt; ({
            click: (e) =&gt; {
                e.dispatch(createAction('tracking-event', {
                    action: 'click',
                    category: 'button',
                    // we define our "label" value as an array
                    // so we can insert additional context values
                    // as our event bubbles up the DOM
                    label: [e.target.innerText]
                }));
            }
        })
    })

    // now, we will attach an event handler to any node that
    // has our new [tracking-context] attribute; the handler
    // inserts its context at the beginning of the label array
    .add({
        type: 'events',
        targets: TrackingContext,
        apply: () =&gt; ({
            'tracking-event': (e) =&gt; {
                const node = e.currentTarget;
                const label = node.getAttribute('tracking-context');
                e.detail.payload.label.unshift(label);
            }
        })
    });
</code></pre>

<p>When the <code>'tracking-event'</code> custom event reaches the root node, <a href="https://github.com/amarajs/plugin-events"><code>@amarajs/plugin-events</code></a> will dispatch it as an action to Amara middleware, including our custom Google Analytics middleware, which joins the label array together and sends the event to GA.</p>

<p>Hopefully, this gives you a better sense of how easy it is to develop features using the AmaraJS framework. We never even touched the existing button component, and yet we've added powerful contextual event tracking to every button instance!</p>

<h3 id="faq">FAQ</h3>

<dl>
<dt>What happens when 2 or more features have the same <code>type</code> and <code>targets</code> properties? Which <code>apply</code> method "wins"?</dt>

<dd>It is the plugin middleware's responsibility to resolve this issue. For example, if the <a href="https://github.com/amarajs/plugin-css"><code>@amarajs/plugin-css</code></a> middleware receives multiple arrays of class names for the same target, it simply combines all the class names together. The HTML5 <code>classList</code> interface ensures uniqueness automatically.</dd>

<dd>But <a href="https://github.com/amarajs/plugin-dom"><code>@amarajs/plugin-dom</code></a> appends each DOM collection it receives to the target element in the order it was received. This ensures that no DOM returned by a feature is mysteriously discarded. If the order the results are applied matters, a custom <code>"sorter"</code> configuration method can be added to the <code>amara</code> instance.</dd>

<dd>More generally, you should read each middleware plugin's documentation to better understand how it applies multiple results to the same target.</dd>
</dl>

<p>Have you hit a roadblock using AmaraJS? If so, please let us know by opening an issue. If we discover that our users are all confronting similar challenges, we can expand this FAQ with (hopefully) useful answers.</p>

    </main>
    <footer><span>&copy; 2018 - Dan Barnes</span></footer>
</body>
</html>